"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var instructions_1 = require("./instructions");
var RADIX = 10;
function getLocationByOffset(str) {
    var locationByOffset = { 0: { line: 1, column: 0 } };
    var currentOffset = 0;
    for (var _i = 0, _a = str.split(''); _i < _a.length; _i++) {
        var char = _a[_i];
        var location_1 = locationByOffset[currentOffset];
        var isNewline = char === '\n';
        locationByOffset[currentOffset + 1] = {
            line: location_1.line + (isNewline ? 1 : 0),
            column: isNewline ? 0 : location_1.column + 1,
        };
        currentOffset++;
    }
    return locationByOffset;
}
exports.getLocationByOffset = getLocationByOffset;
// Parses a sourcemap string
// The solidity sourcemap format is documented here: https://github.com/ethereum/solidity/blob/develop/docs/miscellaneous.rst#source-mappings
function parseSourceMap(sourceCodes, srcMap, bytecodeHex, sources) {
    var bytecode = Uint8Array.from(Buffer.from(bytecodeHex, 'hex'));
    var pcToInstructionIndex = instructions_1.getPcToInstructionIndexMapping(bytecode);
    var locationByOffsetByFileIndex = _.map(sourceCodes, getLocationByOffset);
    var entries = srcMap.split(';');
    var parsedEntries = [];
    var lastParsedEntry = {};
    var instructionIndexToSourceRange = {};
    _.each(entries, function (entry, i) {
        var _a = entry.split(':'), instructionIndexStrIfExists = _a[0], lengthStrIfExists = _a[1], fileIndexStrIfExists = _a[2], jumpTypeStrIfExists = _a[3];
        var instructionIndexIfExists = parseInt(instructionIndexStrIfExists, RADIX);
        var lengthIfExists = parseInt(lengthStrIfExists, RADIX);
        var fileIndexIfExists = parseInt(fileIndexStrIfExists, RADIX);
        var offset = _.isNaN(instructionIndexIfExists) ? lastParsedEntry.offset : instructionIndexIfExists;
        var length = _.isNaN(lengthIfExists) ? lastParsedEntry.length : lengthIfExists;
        var fileIndex = _.isNaN(fileIndexIfExists) ? lastParsedEntry.fileIndex : fileIndexIfExists;
        var parsedEntry = {
            offset: offset,
            length: length,
            fileIndex: fileIndex,
        };
        if (parsedEntry.fileIndex !== -1) {
            var sourceRange = {
                location: {
                    start: locationByOffsetByFileIndex[parsedEntry.fileIndex][parsedEntry.offset],
                    end: locationByOffsetByFileIndex[parsedEntry.fileIndex][parsedEntry.offset + parsedEntry.length],
                },
                fileName: sources[parsedEntry.fileIndex],
            };
            instructionIndexToSourceRange[i] = sourceRange;
        }
        else {
            // Some assembly code generated by Solidity can't be mapped back to a line of source code.
            // Source: https://github.com/ethereum/solidity/issues/3629
        }
        lastParsedEntry = parsedEntry;
    });
    var pcsToSourceRange = {};
    for (var _i = 0, _a = _.keys(pcToInstructionIndex); _i < _a.length; _i++) {
        var programCounterKey = _a[_i];
        var pc = parseInt(programCounterKey, RADIX);
        var instructionIndex = pcToInstructionIndex[pc];
        pcsToSourceRange[pc] = instructionIndexToSourceRange[instructionIndex];
    }
    return pcsToSourceRange;
}
exports.parseSourceMap = parseSourceMap;
//# sourceMappingURL=source_maps.js.map